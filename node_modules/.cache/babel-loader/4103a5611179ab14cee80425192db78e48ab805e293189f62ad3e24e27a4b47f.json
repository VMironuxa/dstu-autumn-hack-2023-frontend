{"ast":null,"code":"import { fetchBaseQuery } from \"@reduxjs/toolkit/query\";\nimport { Mutex } from \"async-mutex\";\nimport { toast } from \"react-toastify\";\nconst mutex = new Mutex();\nconst baseQueryDefault = fetchBaseQuery({\n  baseUrl: \"https://nikko-develop.space/api/\",\n  credentials: \"include\",\n  prepareHeaders: async headers => {\n    var _localStorage$getItem;\n    const token = localStorage.getItem(\"accessToken\");\n    const lang = (_localStorage$getItem = localStorage.getItem(\"lang\")) === null || _localStorage$getItem === void 0 ? void 0 : _localStorage$getItem.toLowerCase();\n    if (token) {\n      headers.set(\"authorization\", `Bearer ${token}`);\n    }\n    headers.set(\"accept\", \"application/json\");\n    headers.set(\"Sec-Fetch-Site\", \"cross-site\");\n    return headers;\n  }\n});\nexport const baseQuery = async (args, api, extraOptions) => {\n  var _result$data, _result$error, _result$error$data;\n  await mutex.waitForUnlock();\n  let result = await baseQueryDefault(args, api, extraOptions);\n  const message = ((_result$data = result.data) === null || _result$data === void 0 ? void 0 : _result$data.message) || ((_result$error = result.error) === null || _result$error === void 0 ? void 0 : (_result$error$data = _result$error.data) === null || _result$error$data === void 0 ? void 0 : _result$error$data.message);\n  if (result.error && (result.error.status.toString().startsWith(\"2\") || result.error.status.toString().startsWith(\"4\"))) {\n    toast.error(message);\n  }\n  if (!result.error) {\n    toast.success(message);\n  }\n  if (result.error && result.error.status === 401) {\n    // checking whether the mutex is locked\n    if (!mutex.isLocked()) {\n      const release = await mutex.acquire();\n      try {\n        var _refreshResult$data;\n        const refreshResult = await baseQueryDefault(\"auth/refresh\", api, extraOptions);\n        if ((_refreshResult$data = refreshResult.data) !== null && _refreshResult$data !== void 0 && _refreshResult$data.accessToken) {\n          var _refreshResult$data2;\n          localStorage.setItem(\"accessToken\", (_refreshResult$data2 = refreshResult.data) === null || _refreshResult$data2 === void 0 ? void 0 : _refreshResult$data2.accessToken);\n          // retry the initial query\n          result = await baseQueryDefault(args, api, extraOptions);\n        } else {\n          localStorage.removeItem(\"accessToken\");\n        }\n      } finally {\n        // release must be called once the mutex should be released again.\n        release();\n      }\n    } else {\n      // wait until the mutex is available without locking it\n      await mutex.waitForUnlock();\n      result = await baseQueryDefault(args, api, extraOptions);\n    }\n  }\n  return result;\n};","map":{"version":3,"names":["fetchBaseQuery","Mutex","toast","mutex","baseQueryDefault","baseUrl","credentials","prepareHeaders","headers","_localStorage$getItem","token","localStorage","getItem","lang","toLowerCase","set","baseQuery","args","api","extraOptions","_result$data","_result$error","_result$error$data","waitForUnlock","result","message","data","error","status","toString","startsWith","success","isLocked","release","acquire","_refreshResult$data","refreshResult","accessToken","_refreshResult$data2","setItem","removeItem"],"sources":["/Users/mironuxa/Documents/GitHub/opportunity-cup-frontend/src/services/settings.ts"],"sourcesContent":["import { fetchBaseQuery } from \"@reduxjs/toolkit/query\";\nimport type {\n  BaseQueryFn,\n  FetchArgs,\n  FetchBaseQueryError,\n} from \"@reduxjs/toolkit/query\";\nimport { Mutex } from \"async-mutex\";\nimport { toast } from \"react-toastify\";\n\nconst mutex = new Mutex();\nconst baseQueryDefault = fetchBaseQuery({\n  baseUrl: \"https://nikko-develop.space/api/\",\n  credentials: \"include\",\n  prepareHeaders: async (headers) => {\n    const token = localStorage.getItem(\"accessToken\");\n    const lang = localStorage.getItem(\"lang\")?.toLowerCase();\n    if (token) {\n      headers.set(\"authorization\", `Bearer ${token}`);\n    }\n    headers.set(\"accept\", \"application/json\");\n    headers.set(\"Sec-Fetch-Site\", \"cross-site\");\n\n    return headers;\n  },\n});\n\nexport const baseQuery: BaseQueryFn<\n  string | FetchArgs,\n  unknown,\n  FetchBaseQueryError\n> = async (args, api, extraOptions) => {\n  await mutex.waitForUnlock();\n  let result = await baseQueryDefault(args, api, extraOptions);\n  const message =\n    (result.data as any)?.message || (result.error?.data as any)?.message;\n  if (\n    result.error &&\n    (result.error.status.toString().startsWith(\"2\") ||\n      result.error.status.toString().startsWith(\"4\"))\n  ) {\n    toast.error(message);\n  }\n  if (!result.error) {\n    toast.success(message);\n  }\n\n  if (result.error && result.error.status === 401) {\n    // checking whether the mutex is locked\n    if (!mutex.isLocked()) {\n      const release = await mutex.acquire();\n      try {\n        const refreshResult = await baseQueryDefault(\n          \"auth/refresh\",\n          api,\n          extraOptions\n        );\n        if ((refreshResult.data as any)?.accessToken) {\n          localStorage.setItem(\n            \"accessToken\",\n            (refreshResult.data as any)?.accessToken\n          );\n          // retry the initial query\n          result = await baseQueryDefault(args, api, extraOptions);\n        } else {\n          localStorage.removeItem(\"accessToken\");\n        }\n      } finally {\n        // release must be called once the mutex should be released again.\n        release();\n      }\n    } else {\n      // wait until the mutex is available without locking it\n      await mutex.waitForUnlock();\n      result = await baseQueryDefault(args, api, extraOptions);\n    }\n  }\n  return result;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}